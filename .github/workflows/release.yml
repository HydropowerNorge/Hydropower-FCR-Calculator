name: Publish Desktop Artifacts

on:
  push:
    branches:
      - main
    paths:
      - package.json
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  detect-version-bump:
    name: Detect version bump
    runs-on: ubuntu-latest
    outputs:
      should_publish: ${{ steps.check.outputs.should_publish }}
      current_version: ${{ steps.check.outputs.current_version }}
      previous_version: ${{ steps.check.outputs.previous_version }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect semver increase
        id: check
        shell: bash
        run: |
          set -euo pipefail
          node <<'NODE' >> "$GITHUB_OUTPUT"
          const fs = require('node:fs');
          const { execSync } = require('node:child_process');

          const eventName = process.env.GITHUB_EVENT_NAME;
          const currentVersion = JSON.parse(fs.readFileSync('package.json', 'utf8')).version || '';

          let previousVersion = '';
          let shouldPublish = false;

          if (eventName === 'workflow_dispatch') {
            shouldPublish = true;
          } else {
            try {
              const prevPkg = execSync('git show HEAD^:package.json', { encoding: 'utf8' });
              previousVersion = JSON.parse(prevPkg).version || '';
            } catch {
              // First commit on branch or missing previous package.json: allow publish.
              shouldPublish = true;
            }

            if (!shouldPublish) {
              const parseSemver = (value) => {
                const match = String(value).trim().match(/^(\d+)\.(\d+)\.(\d+)(?:[-+].*)?$/);
                return match ? [Number(match[1]), Number(match[2]), Number(match[3])] : null;
              };

              const compareSemver = (a, b) => {
                const pa = parseSemver(a);
                const pb = parseSemver(b);
                if (!pa || !pb) return null;
                for (let i = 0; i < 3; i += 1) {
                  if (pa[i] !== pb[i]) return pa[i] - pb[i];
                }
                return 0;
              };

              const cmp = compareSemver(currentVersion, previousVersion);
              shouldPublish = cmp === null ? currentVersion !== previousVersion : cmp > 0;
            }
          }

          console.log(`current_version=${currentVersion}`);
          console.log(`previous_version=${previousVersion}`);
          console.log(`should_publish=${shouldPublish ? 'true' : 'false'}`);
          NODE

  publish:
    name: Publish on ${{ matrix.os }} (${{ matrix.arch }})
    needs: detect-version-bump
    if: ${{ needs.detect-version-bump.outputs.should_publish == 'true' }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        include:
          - os: ubuntu-latest
            arch: x64
          - os: windows-latest
            arch: x64
          - os: windows-latest
            arch: arm64
          - os: macos-latest
            arch: arm64
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Prepare runtime configuration
        shell: bash
        env:
          CONVEX_URL: ${{ secrets.CONVEX_URL }}
          ELECTRON_AUTO_UPDATE_REPO: ${{ vars.ELECTRON_AUTO_UPDATE_REPO }}
          ELECTRON_AUTO_UPDATE_HOST: ${{ vars.ELECTRON_AUTO_UPDATE_HOST }}
        run: |
          set -euo pipefail
          if [ -z "${CONVEX_URL:-}" ]; then
            echo "::error::Missing required secret CONVEX_URL (production Convex deployment URL)."
            exit 1
          fi

          AUTO_UPDATE_REPO="${ELECTRON_AUTO_UPDATE_REPO:-HydropowerNorge/Hydropower-FCR-Calculator}"
          AUTO_UPDATE_HOST="${ELECTRON_AUTO_UPDATE_HOST:-https://update.electronjs.org}"

          if [[ "$AUTO_UPDATE_REPO" != */* ]]; then
            echo "::error::ELECTRON_AUTO_UPDATE_REPO must be in owner/repo format. Got: $AUTO_UPDATE_REPO"
            exit 1
          fi

          if [[ "$AUTO_UPDATE_HOST" != https://* ]]; then
            echo "::error::ELECTRON_AUTO_UPDATE_HOST must start with https://. Got: $AUTO_UPDATE_HOST"
            exit 1
          fi

          {
            printf 'CONVEX_URL=%s\n' "$CONVEX_URL"
            printf 'ELECTRON_AUTO_UPDATE_REPO=%s\n' "$AUTO_UPDATE_REPO"
            printf 'ELECTRON_AUTO_UPDATE_HOST=%s\n' "$AUTO_UPDATE_HOST"
          } > .env

      - name: Prepare macOS signing and notarization
        if: runner.os == 'macOS'
        shell: bash
        env:
          MACOS_SIGNING_CERT_P12: ${{ secrets.MACOS_SIGNING_CERT_P12 }}
          MACOS_SIGNING_CERT_PASSWORD: ${{ secrets.MACOS_SIGNING_CERT_PASSWORD }}
          MACOS_CODESIGN_IDENTITY: ${{ secrets.MACOS_CODESIGN_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_NOTARY_KEYCHAIN_PROFILE: ${{ secrets.APPLE_NOTARY_KEYCHAIN_PROFILE }}
          APPLE_API_KEY_P8: ${{ secrets.APPLE_API_KEY_P8 }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          set -euo pipefail

          if [ -z "${MACOS_SIGNING_CERT_P12:-}" ] || [ -z "${MACOS_SIGNING_CERT_PASSWORD:-}" ] || [ -z "${MACOS_CODESIGN_IDENTITY:-}" ]; then
            echo "::error::Missing required macOS signing secrets: MACOS_SIGNING_CERT_P12, MACOS_SIGNING_CERT_PASSWORD, MACOS_CODESIGN_IDENTITY"
            exit 1
          fi

          if [ -n "${APPLE_API_KEY_P8:-}" ] && { [ -z "${APPLE_API_KEY_ID:-}" ] || [ -z "${APPLE_API_ISSUER:-}" ]; }; then
            echo "::error::APPLE_API_KEY_P8 requires APPLE_API_KEY_ID and APPLE_API_ISSUER"
            exit 1
          fi

          CERT_PATH="$RUNNER_TEMP/macos-signing-cert.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/hydropower-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -hex 16)"

          echo "$MACOS_SIGNING_CERT_P12" | base64 --decode > "$CERT_PATH"
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -P "$MACOS_SIGNING_CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
          security list-keychains -d user -s "$KEYCHAIN_PATH" ~/Library/Keychains/login.keychain-db
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          if [ -n "${APPLE_API_KEY_P8:-}" ] && [ -n "${APPLE_API_KEY_ID:-}" ]; then
            API_KEY_PATH="$RUNNER_TEMP/AuthKey_${APPLE_API_KEY_ID}.p8"
            printf '%s' "$APPLE_API_KEY_P8" > "$API_KEY_PATH"
            chmod 600 "$API_KEY_PATH"
            echo "APPLE_API_KEY_PATH=$API_KEY_PATH" >> "$GITHUB_ENV"
          fi

          if [ -z "${APPLE_NOTARY_KEYCHAIN_PROFILE:-}" ] && \
             { [ -z "${APPLE_API_KEY_P8:-}" ] || [ -z "${APPLE_API_KEY_ID:-}" ] || [ -z "${APPLE_API_ISSUER:-}" ]; } && \
             { [ -z "${APPLE_ID:-}" ] || [ -z "${APPLE_APP_SPECIFIC_PASSWORD:-}" ] || [ -z "${APPLE_TEAM_ID:-}" ]; }; then
            echo "::warning::No notarization credentials configured. macOS artifacts will be signed but not notarized."
          fi

      - name: Publish artifacts to S4 and GitHub Releases
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.S4_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.S4_SECRET_KEY }}
          AWS_REGION: ${{ secrets.S4_REGION }}
          AWS_DEFAULT_REGION: ${{ secrets.S4_REGION }}
          S4_ENDPOINT: ${{ secrets.S4_ENDPOINT }}
          S4_BUCKET: ${{ secrets.S4_BUCKET }}
          S4_REGION: ${{ secrets.S4_REGION }}
          S4_UPDATES_PREFIX: ${{ secrets.S4_UPDATES_PREFIX }}
          S4_PUBLIC_UPDATES_BASE_URL: ${{ secrets.S4_PUBLIC_UPDATES_BASE_URL }}
          S4_OMIT_ACL: ${{ secrets.S4_OMIT_ACL }}
          S4_ENABLE_WINDOWS_REMOTE_RELEASES: ${{ secrets.S4_ENABLE_WINDOWS_REMOTE_RELEASES }}
          MACOS_CODESIGN_IDENTITY: ${{ secrets.MACOS_CODESIGN_IDENTITY }}
          MACOS_APP_BUNDLE_ID: ${{ secrets.MACOS_APP_BUNDLE_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_NOTARY_KEYCHAIN_PROFILE: ${{ secrets.APPLE_NOTARY_KEYCHAIN_PROFILE }}
          APPLE_API_KEY_PATH: ${{ env.APPLE_API_KEY_PATH }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          set -euo pipefail
          max_attempts=3
          attempt=1
          while [ "$attempt" -le "$max_attempts" ]; do
            echo "Publish attempt ${attempt}/${max_attempts}"
            if npm run publish -- --arch=${{ matrix.arch }}; then
              exit 0
            fi
            if [ "$attempt" -lt "$max_attempts" ]; then
              echo "Publish failed. Retrying in 15 seconds..."
              sleep 15
            fi
            attempt=$((attempt + 1))
          done

          echo "Publish failed after ${max_attempts} attempts."
          exit 1

  prune-s4-old-artifacts:
    name: Prune old S4 artifacts
    needs: [detect-version-bump, publish]
    if: ${{ needs.publish.result == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Resolve current app version
        id: version
        shell: bash
        run: |
          set -euo pipefail
          echo "value=$(node -p \"require('./package.json').version\")" >> "$GITHUB_OUTPUT"

      - name: Prune previous release files from S4 updates prefix
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.S4_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.S4_SECRET_KEY }}
          S4_ENDPOINT: ${{ secrets.S4_ENDPOINT }}
          S4_BUCKET: ${{ secrets.S4_BUCKET }}
          S4_REGION: ${{ secrets.S4_REGION }}
          S4_UPDATES_PREFIX: ${{ secrets.S4_UPDATES_PREFIX }}
          CURRENT_VERSION: ${{ steps.version.outputs.value }}
        run: |
          set -euo pipefail
          python3 -m pip install --quiet boto3
          python3 - <<'PY'
          import os
          import sys
          import boto3
          from botocore.config import Config

          endpoint = (os.getenv('S4_ENDPOINT') or 'https://s3.eu-central-1.s4.mega.io').rstrip('/')
          bucket = os.getenv('S4_BUCKET') or 'app'
          region = os.getenv('S4_REGION') or 'eu-central-1'
          updates_prefix = (os.getenv('S4_UPDATES_PREFIX') or 'updates').strip('/')
          current_version = (os.getenv('CURRENT_VERSION') or '').strip()

          if not current_version:
            print('Missing CURRENT_VERSION')
            sys.exit(1)

          key_prefix = f'{updates_prefix}/'
          keep_markers = {
            f'-{current_version}',
            f'_{current_version}'
          }
          keep_basenames = {'RELEASES', 'RELEASES.json'}

          s3 = boto3.client(
            's3',
            endpoint_url=endpoint,
            aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
            aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
            region_name=region,
            config=Config(signature_version='s3v4')
          )

          paginator = s3.get_paginator('list_objects_v2')
          objects = []
          for page in paginator.paginate(Bucket=bucket, Prefix=key_prefix):
            objects.extend(page.get('Contents', []))

          delete_keys = []
          for obj in objects:
            key = obj['Key']
            base = key.rsplit('/', 1)[-1]
            should_keep = (
              base in keep_basenames or
              any(marker in base for marker in keep_markers)
            )
            if not should_keep:
              delete_keys.append(key)

          if not delete_keys:
            print(f'No old files to delete under {key_prefix}')
            sys.exit(0)

          print(f'Deleting {len(delete_keys)} old files under {key_prefix}')
          for i in range(0, len(delete_keys), 1000):
            chunk = delete_keys[i:i + 1000]
            resp = s3.delete_objects(
              Bucket=bucket,
              Delete={'Objects': [{'Key': key} for key in chunk], 'Quiet': True}
            )
            for err in resp.get('Errors', []):
              print(f"Failed to delete {err.get('Key')}: {err.get('Code')} {err.get('Message')}")
              sys.exit(1)

          print('S4 prune complete')
          PY
