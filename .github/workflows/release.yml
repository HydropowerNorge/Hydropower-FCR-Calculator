name: Publish Desktop Artifacts

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  publish:
    name: Publish on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        os:
          - ubuntu-latest
          - windows-latest
          - macos-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Validate tag/version
        if: startsWith(github.ref, 'refs/tags/')
        shell: bash
        run: |
          node -e "const pkg=require('./package.json'); const tag=process.env.GITHUB_REF_NAME; const expected='v'+pkg.version; if(tag!==expected){console.error(`Tag ${tag} does not match package.json version ${pkg.version}`); process.exit(1);}"

      - name: Install dependencies
        run: npm ci

      - name: Prepare macOS signing and notarization
        if: runner.os == 'macOS'
        shell: bash
        env:
          MACOS_SIGNING_CERT_P12: ${{ secrets.MACOS_SIGNING_CERT_P12 }}
          MACOS_SIGNING_CERT_PASSWORD: ${{ secrets.MACOS_SIGNING_CERT_PASSWORD }}
          MACOS_CODESIGN_IDENTITY: ${{ secrets.MACOS_CODESIGN_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_NOTARY_KEYCHAIN_PROFILE: ${{ secrets.APPLE_NOTARY_KEYCHAIN_PROFILE }}
          APPLE_API_KEY_P8: ${{ secrets.APPLE_API_KEY_P8 }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          set -euo pipefail

          if [ -z "${MACOS_SIGNING_CERT_P12:-}" ] || [ -z "${MACOS_SIGNING_CERT_PASSWORD:-}" ] || [ -z "${MACOS_CODESIGN_IDENTITY:-}" ]; then
            echo "::error::Missing required macOS signing secrets: MACOS_SIGNING_CERT_P12, MACOS_SIGNING_CERT_PASSWORD, MACOS_CODESIGN_IDENTITY"
            exit 1
          fi

          if [ -n "${APPLE_API_KEY_P8:-}" ] && { [ -z "${APPLE_API_KEY_ID:-}" ] || [ -z "${APPLE_API_ISSUER:-}" ]; }; then
            echo "::error::APPLE_API_KEY_P8 requires APPLE_API_KEY_ID and APPLE_API_ISSUER"
            exit 1
          fi

          CERT_PATH="$RUNNER_TEMP/macos-signing-cert.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/hydropower-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -hex 16)"

          echo "$MACOS_SIGNING_CERT_P12" | base64 --decode > "$CERT_PATH"
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -P "$MACOS_SIGNING_CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
          security list-keychains -d user -s "$KEYCHAIN_PATH" ~/Library/Keychains/login.keychain-db
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          if [ -n "${APPLE_API_KEY_P8:-}" ] && [ -n "${APPLE_API_KEY_ID:-}" ]; then
            API_KEY_PATH="$RUNNER_TEMP/AuthKey_${APPLE_API_KEY_ID}.p8"
            printf '%s' "$APPLE_API_KEY_P8" > "$API_KEY_PATH"
            chmod 600 "$API_KEY_PATH"
            echo "APPLE_API_KEY_PATH=$API_KEY_PATH" >> "$GITHUB_ENV"
          fi

          if [ -z "${APPLE_NOTARY_KEYCHAIN_PROFILE:-}" ] && \
             { [ -z "${APPLE_API_KEY_P8:-}" ] || [ -z "${APPLE_API_KEY_ID:-}" ] || [ -z "${APPLE_API_ISSUER:-}" ]; } && \
             { [ -z "${APPLE_ID:-}" ] || [ -z "${APPLE_APP_SPECIFIC_PASSWORD:-}" ] || [ -z "${APPLE_TEAM_ID:-}" ]; }; then
            echo "::warning::No notarization credentials configured. macOS artifacts will be signed but not notarized."
          fi

      - name: Publish artifacts to S4 and GitHub Releases
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.S4_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.S4_SECRET_KEY }}
          AWS_REGION: ${{ secrets.S4_REGION }}
          AWS_DEFAULT_REGION: ${{ secrets.S4_REGION }}
          S4_ENDPOINT: ${{ secrets.S4_ENDPOINT }}
          S4_BUCKET: ${{ secrets.S4_BUCKET }}
          S4_REGION: ${{ secrets.S4_REGION }}
          S4_UPDATES_PREFIX: ${{ secrets.S4_UPDATES_PREFIX }}
          S4_OMIT_ACL: ${{ secrets.S4_OMIT_ACL }}
          S4_ENABLE_WINDOWS_REMOTE_RELEASES: ${{ secrets.S4_ENABLE_WINDOWS_REMOTE_RELEASES }}
          MACOS_CODESIGN_IDENTITY: ${{ secrets.MACOS_CODESIGN_IDENTITY }}
          MACOS_APP_BUNDLE_ID: ${{ secrets.MACOS_APP_BUNDLE_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_NOTARY_KEYCHAIN_PROFILE: ${{ secrets.APPLE_NOTARY_KEYCHAIN_PROFILE }}
          APPLE_API_KEY_PATH: ${{ env.APPLE_API_KEY_PATH }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          set -euo pipefail
          max_attempts=3
          attempt=1
          while [ "$attempt" -le "$max_attempts" ]; do
            echo "Publish attempt ${attempt}/${max_attempts}"
            if npm run publish; then
              exit 0
            fi
            if [ "$attempt" -lt "$max_attempts" ]; then
              echo "Publish failed. Retrying in 15 seconds..."
              sleep 15
            fi
            attempt=$((attempt + 1))
          done

          echo "Publish failed after ${max_attempts} attempts."
          exit 1

  prune-s4-old-artifacts:
    name: Prune old S4 artifacts
    needs: publish
    if: ${{ needs.publish.result == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Resolve current app version
        id: version
        shell: bash
        run: |
          set -euo pipefail
          echo "value=$(node -p \"require('./package.json').version\")" >> "$GITHUB_OUTPUT"

      - name: Prune previous release files from S4 updates prefix
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.S4_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.S4_SECRET_KEY }}
          S4_ENDPOINT: ${{ secrets.S4_ENDPOINT }}
          S4_BUCKET: ${{ secrets.S4_BUCKET }}
          S4_REGION: ${{ secrets.S4_REGION }}
          S4_UPDATES_PREFIX: ${{ secrets.S4_UPDATES_PREFIX }}
          CURRENT_VERSION: ${{ steps.version.outputs.value }}
        run: |
          set -euo pipefail
          python3 -m pip install --quiet boto3
          python3 - <<'PY'
          import os
          import sys
          import boto3
          from botocore.config import Config

          endpoint = (os.getenv('S4_ENDPOINT') or 'https://s3.eu-central-1.s4.mega.io').rstrip('/')
          bucket = os.getenv('S4_BUCKET') or 'app'
          region = os.getenv('S4_REGION') or 'eu-central-1'
          updates_prefix = (os.getenv('S4_UPDATES_PREFIX') or 'updates').strip('/')
          current_version = (os.getenv('CURRENT_VERSION') or '').strip()

          if not current_version:
            print('Missing CURRENT_VERSION')
            sys.exit(1)

          key_prefix = f'{updates_prefix}/'
          keep_markers = {
            f'-{current_version}',
            f'_{current_version}'
          }
          keep_basenames = {'RELEASES', 'RELEASES.json'}

          s3 = boto3.client(
            's3',
            endpoint_url=endpoint,
            aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
            aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
            region_name=region,
            config=Config(signature_version='s3v4')
          )

          paginator = s3.get_paginator('list_objects_v2')
          objects = []
          for page in paginator.paginate(Bucket=bucket, Prefix=key_prefix):
            objects.extend(page.get('Contents', []))

          delete_keys = []
          for obj in objects:
            key = obj['Key']
            base = key.rsplit('/', 1)[-1]
            should_keep = (
              base in keep_basenames or
              any(marker in base for marker in keep_markers)
            )
            if not should_keep:
              delete_keys.append(key)

          if not delete_keys:
            print(f'No old files to delete under {key_prefix}')
            sys.exit(0)

          print(f'Deleting {len(delete_keys)} old files under {key_prefix}')
          for i in range(0, len(delete_keys), 1000):
            chunk = delete_keys[i:i + 1000]
            resp = s3.delete_objects(
              Bucket=bucket,
              Delete={'Objects': [{'Key': key} for key in chunk], 'Quiet': True}
            )
            for err in resp.get('Errors', []):
              print(f"Failed to delete {err.get('Key')}: {err.get('Code')} {err.get('Message')}")
              sys.exit(1)

          print('S4 prune complete')
          PY
